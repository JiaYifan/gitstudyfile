<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>排序算法</title>
<script src="../../js/jquery-1.11.3.min.js"></script>
<style type="text/css">
p{line-height:150%; font-family: "Microsoft YaHei";}/*text-indent:2em;border-style: solid dotted dashed double;*/
ul{margin:0px;}
li{margin-bottom: 8px;}
table{margin-left: 2em;}
h3{cursor:pointer;margin:19px 0 0 0;}
img{width: 100%;max-width: 850px;}
.all{width: 100%;max-width: 1000px;margin:0 auto;}
.innerimg{max-width: 500px;}
.content{float:left;border-style:double double double double;margin:0 auto;}
.top{float: left;width: 100%;}
.menulist{display:none;border-style:dotted dotted dotted dotted; padding:0 0 0 8px; margin: 0 0 15px 0;float: left;min-width:500px;width: 50%;margin-right: 50%;}
</style>
<script>
	$(document).ready(function(){
		$('.top').children('h3').click(function(){
			var list = $(this).parent().next();
			var show = list.css('display');
			list.css('display',show =='block'?'none':'block');
		})
	});
</script>
</head>

<body>

<div style="float:left;width:100%">
<h1 align="center">排序算法</h1>
<hr/>
</div>

<div class="all">

<div align="center"><img src="../img/排序算法.png">
<p>注：“稳定的”是指若两个数字相同，在排序过后，这两个数字的相对顺序不变</p></div>

<div style="float:left;text-align: center;">
<h3 align="center">插入排序</h3>
<p align="center" style="margin:0px">（思想：每步将一个待排序的对象, 按其排序码大小, 插入到前面已经排好序的一组对象的适当位置上, 直到对象全部插入为止。）</p>
	<div class="content">
	<div class="top"><h3>直接插入排序（时间复杂度：O(n^2)。稳定的）</h3></div> 
	<div class="menulist">
		<p>方法：当插入第i (i >= 1) 个对象时, 前面的V[0], V[1], …, V[i-1]已经排好序。这时, 用V[i]的排序码依次与V[i-1], V[i-2], …的排序码顺序进行比较, 找到插入位置即将V[i]插入, 原来位置上的对象向后顺移。</p>
		<h4>图解</h4>
		<div class="innerimg"><img src="../img/直接插入排序.gif"></div>
		<p>注：为啥要设置哨兵？因为如果第i个元素是最小的，依次比较到V[0]时，因为比V[0]小，则会继续往前找，就越界了。
		<br>所以设置哨兵的好处：1、暂时存放待插入的元素；2、防止数组下标越界</p>
	</div>
	<div class="top"><h3>希尔排序（时间复杂度：n^1.25 ~ 1.6*n^1.25之间（统计资料）。不稳定的。gap的取值会影响希尔排序的效率。）</h3></div> 
	<div class="menulist">
		<p>方法： 因为在“直接插入排序”过程中，若元素已经基本有序，那么“直接插入排序”的效率较高。引出了“希尔排序”的基本思想：
	    <br>1. 设待排序的序列有 n 个对象，首先取一个整数 gap < n 作为间隔, 将下标相差为gap的倍数对象放在一组。 
	    <br>2. 在组内作 直接插入排序。 
	    <br>3. 然后逐渐缩小间隔 gap, 例如取 gap = gap/2，重复上述的组划分和排序工作。直到最后取 gap == 1, 将所有对象放在同一个组中进行排序为止。</p>
		<h4>图解</h4>
		<div class="innerimg"><img src="../img/希尔排序.gif"></div>
	</div>
	</div>
</div>

<div style="float:left">
<h3 align="center">交换排序</h3>
<p align="center" style="margin:0px">（思想：两两比较待排序对象的排序码,如果发生逆序，则进行交换。直到所有对象都排好序为止。）</p>
	<div class="content">
	<div class="top"><h3>冒泡排序（时间复杂度：O(n^2)。稳定的。）</h3></div> 
	<div class="menulist">
		<p>方法：<br>1. 对待排序序列从前向后（从下标较大的元素开始）依次比较相邻元素的关键字，若发现逆序则交换；<br>2. 使较小的元素逐渐前移（或者较大的元素逐渐后移）；（假定按照“从小到大”排序）</p>
		<h4>图解</h4>
		<div class="innerimg"><img src="../img/冒泡排序.gif"></div>
		<p>注：如果一趟比较下来没有进行过交换，就说明序列已经有序；可以通过设置一个标志exchange记录一趟遍历中是否进行了交换。</p>
	</div>
	<div class="top"><h3>快速排序（时间复杂度：最好 O(N*logN)，最差 O(N^2)。空间复杂度：最好 O(logN)，最差 O(N)。不稳定的。）</h3></div> 
	<div class="menulist">
		<p>方法： 因为在“直接插入排序”过程中，若元素已经基本有序，那么“直接插入排序”的效率较高。引出了“希尔排序”的基本思想：
	    <br>1. 设待排序的序列有 n 个对象，首先取一个整数 gap < n 作为间隔, 将下标相差为gap的倍数对象放在一组。 
	    <br>2. 在组内作 直接插入排序。 
	    <br>3. 然后逐渐缩小间隔 gap, 例如取 gap = gap/2，重复上述的组划分和排序工作。直到最后取 gap == 1, 将所有对象放在同一个组中进行排序为止。</p>
		<h4>图解</h4>
		<div class="innerimg"><img src="../img/希尔排序.gif"></div>
	</div>
	</div>
</div>

</div>
</body>
</html>